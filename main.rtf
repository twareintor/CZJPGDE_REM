{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fmodern Courier;}}
{\colortbl\red0\green128\blue0;\red0\green0\blue255;\red0\green0\blue0;}
{\info{\comment Generated by the SynEdit RTF exporter}
{\title main.rtf}}

\deflang1033\pard\plain\f0\fs20 \cf0 /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
\par // Progetto Originale: "CZJPGDE.DEV" // 
\par // nome del file: "main.cpp"
\par /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
\par /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
\par 
\par \cf1 #include "czjpgcde.h"
\par 
\par \cf0 /* This is where all the input to the window goes to */
\par \cf2 LRESULT CALLBACK WndProc(HWND hwnd, UINT Message, WPARAM wParam, LPARAM lParam) \{
\par 	\cf1 switch\cf2 (Message) \{
\par 		\cf1 case\cf2  WM_CREATE:
\par 		\{
\par 			\cf0 // General_Disclaimer();
\par \cf2 			g_szFNX = (LPTSTR)GlobalAlloc(GPTR, MAX_PATH*4);	\cf0 // make room for the current file name loaded into the form
\par \cf2 			\cf0 // CXLogPrint("d:\\\\tmp\\\\logprn.txt", 10, "Program start...", TRUE);	// WARNING!!! THIS FUNCTION IS DEFECT!!!
\par \cf2 			\cf1 break\cf2 ;
\par 		\}
\par 		\cf1 case\cf2  WM_LBUTTONDOWN:
\par 		\{
\par 			\cf1 if\cf2 (CX_HTITLE>=1)
\par 			\{
\par 				POINT		Mouse = \{LOWORD(lParam), HIWORD(lParam)\};
\par 				LPRECT		lprcAreas;
\par 				LPRECT		lprcOpen;
\par 				
\par 				lprcOpen = (LPRECT)GlobalAlloc(GPTR, \cf1 sizeof\cf2 (RECT));
\par 				lprcAreas = (LPRECT)GlobalAlloc(GPTR, \cf1 sizeof\cf2 (RECT)*5);
\par 				
\par 				CZTitleBar		cztb(hwnd, 18, lprcAreas, TRUE);
\par 				\cf1 for\cf2 (\cf1 int\cf2  i=0; i<=4; i++)
\par 				\{
\par 					\cf1 if\cf2 (PtInRect(lprcAreas+i, Mouse))
\par 					\{
\par 						\cf1 switch\cf2 (i)\{
\par 							\cf1 case\cf2  4:
\par 							\{
\par 								\cf1 int\cf2  nMsgRes = 
\par 									MessageBoxW(hwnd, L"Are you sure you want to close?", L"Application close", MB_YESNO|MB_ICONQUESTION); 
\par 								\cf1 if\cf2 (nMsgRes==IDYES)
\par 								\{
\par 									PostQuitMessage(0);
\par 								\}
\par 								\cf1 break\cf2 ;
\par 							\}
\par 						\}
\par 					\}
\par 				\}
\par 				GlobalFree(lprcAreas);
\par 			\}
\par 			\cf1 break\cf2 ;
\par 		\}
\par 		\cf1 case\cf2  WM_PAINT:
\par 		\{
\par 			\cf1 if\cf2 (CX_HTITLE>=1)
\par 			\{
\par 				CZTitleBar	cztitlebar(hwnd, 18, NULL, TRUE);	\cf0 // this draws the custom title bar
\par \cf2 				\cf0 // place to draw toolbar(s)
\par \cf2 			\}
\par 			SaveFormImageOnMem(hwnd, TRUE);
\par 			\cf1 break\cf2 ;
\par 		\}
\par 		\cf1 case\cf2  WM_COMMAND:
\par 		\{
\par 			\cf1 switch\cf2 (LOWORD(wParam))\{
\par 				\cf1 case\cf2  ID_FILE_OPEN:
\par 				\{
\par 					LPSTR			szFNm = (LPSTR)GlobalAlloc(GPTR, MAX_PATH);
\par 					\cf1 if\cf2 (ProvideTheFileName(hwnd, szFNm)==3604)
\par 					\{
\par 						CXOpenFile(hwnd, NULL, szFNm);
\par 						memset(g_szFNX, 0, MAX_PATH*4);
\par 						memcpy(g_szFNX, szFNm, strlen(szFNm));
\par 						SaveFormImageOnMem(hwnd, FALSE);
\par 					\}
\par 					GlobalFree(szFNm);
\par 					\cf1 break\cf2 ;
\par 				\}
\par 				\cf1 case\cf2  ID_FILE_EXIT:
\par 				\{
\par 					\cf1 int\cf2  nMsgRes = 
\par 						MessageBoxW(hwnd, L"Are you sure you want to close?", L"Application close", MB_YESNO|MB_ICONQUESTION); 
\par 					\cf1 if\cf2 (nMsgRes==IDYES)
\par 					\{
\par 						PostQuitMessage(0);
\par 					\}
\par 					\cf1 break\cf2 ;
\par 				\}
\par 				\cf1 case\cf2  ID_TRANSFORM_FILES:
\par 				\{
\par 					\cf1 int\cf2  ncxmodRes = CXModifyJpgImage(hwnd, 800, 0);
\par 					MessageBox(hwnd, "Done!", "File(s) transform result", MB_OK);
\par 					\cf1 break\cf2 ;
\par 				\}
\par 			\}
\par 			\cf1 break\cf2 ;
\par 		\}
\par 		\cf1 case\cf2  WM_KEYDOWN:
\par 		\{
\par 			\cf1 switch\cf2 (wParam)
\par 			\{
\par 				\cf1 case\cf2  VK_LEFT:
\par 				\{
\par 					CXNextFileInDirectory(g_szFNX, -1);
\par 					CXOpenFile(hwnd, NULL, g_szFNX);
\par 					SaveFormImageOnMem(hwnd, FALSE);
\par 					\cf1 break\cf2 ;
\par 				\}
\par 				\cf1 case\cf2  VK_RIGHT:
\par 				\{
\par 					CXNextFileInDirectory(g_szFNX,  1);
\par 					CXOpenFile(hwnd, NULL, g_szFNX);
\par 					SaveFormImageOnMem(hwnd, FALSE);
\par 					\cf1 break\cf2 ;
\par 				\}
\par 			\}
\par 			\cf1 break\cf2 ;
\par 		\}
\par 		\cf1 case\cf2  WM_KILLFOCUS:
\par 		\{
\par 			\cf1 if\cf2 (CX_HTITLE>=1)
\par 				CZTitleBar		cztb(hwnd, 18, NULL, FALSE);
\par 			\cf1 break\cf2 ;
\par 		\}
\par 		\cf1 case\cf2  WM_SETFOCUS:
\par 		\{
\par 			\cf1 if\cf2 (CX_HTITLE>=1)
\par 				CZTitleBar		cztb(hwnd, 18, NULL, TRUE);
\par 			\cf1 break\cf2 ;
\par 		\}
\par 		\cf0 /* Upon destruction, tell the main thread to stop */
\par \cf2 		\cf1 case\cf2  WM_DESTROY: 
\par 		\{
\par 			GlobalFree(g_szFNX);
\par 			PostQuitMessage(0);
\par 			\cf1 break\cf2 ;
\par 		\}
\par 		\cf0 /* All other messages (a lot of them) are processed using default procedures */
\par \cf2 		\cf1 default\cf2 :
\par 			\cf1 return\cf2  DefWindowProc(hwnd, Message, wParam, lParam);
\par 	\}
\par 	\cf1 return\cf2  0;
\par \}
\par 
\par \cf0 /* The 'main' function of Win32 GUI programs: this is where execution starts */
\par \cf1 int\cf2  WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, \cf1 int\cf2  nCmdShow) \{
\par 	WNDCLASSEX wc; \cf0 /* A properties struct of our window */
\par \cf2 	HWND hwnd; \cf0 /* A 'HANDLE', hence the H, or a pointer to our window */
\par \cf2 	MSG Msg; \cf0 /* A temporary location for all messages */
\par 
\par \cf2 	\cf0 /* zero out the struct and set the stuff we want to modify */
\par \cf2 	memset(&wc,0,\cf1 sizeof\cf2 (wc));
\par 	wc.cbSize		 = \cf1 sizeof\cf2 (WNDCLASSEX);
\par 	wc.lpfnWndProc	 = WndProc; \cf0 /* This is where we will send messages to */
\par \cf2 	wc.hInstance	 = hInstance;
\par 	wc.hCursor		 = LoadCursor(NULL, IDC_ARROW);
\par 	
\par 	\cf0 /* White, COLOR_WINDOW is just a #define for a system color, try Ctrl+Clicking it */
\par \cf2 	wc.hbrBackground = (HBRUSH)(COLOR_WINDOW);
\par 	wc.lpszClassName = "WindowClass";
\par 	wc.hIcon		 = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_MYICON)); \cf0 /* Load a standard icon */
\par \cf2 	wc.hIconSm		 = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_MYICONSM)); \cf0 /* use the name "A" to use the project icon */
\par 
\par \cf2 	\cf1 if\cf2 (!RegisterClassEx(&wc)) \{
\par 		MessageBox(NULL, "Window Registration Failed!","Error!",MB_ICONEXCLAMATION|MB_OK);
\par 		\cf1 return\cf2  0;
\par 	\}
\par 
\par 	HMENU hmenu = LoadMenu(hInstance, MAKEINTRESOURCE(IDR_MYMENU));
\par 	\cf1 if\cf2 (CX_HTITLE>=1) hmenu = NULL;
\par 	DWORD	dwStyle1 = (WS_EX_STATICEDGE*(CX_HTITLE>=1))|(WS_EX_CLIENTEDGE*(CX_HTITLE<=0));
\par 	DWORD	dwStyle2 = (WS_POPUPWINDOW*(CX_HTITLE>=1))|(WS_OVERLAPPEDWINDOW*(CX_HTITLE<=0));
\par 	hwnd = CreateWindowEx(dwStyle1,"WindowClass","CX Image Info - Version Alpha 000 - - - TEST VERSION", dwStyle2|WS_VISIBLE,
\par 		0, \cf0 /* x */
\par \cf2 		0, \cf0 /* y */
\par \cf2 		GetSystemMetrics(SM_CXSCREEN)*3/4, \cf0 /* width */
\par \cf2 		GetSystemMetrics(SM_CXSCREEN)*3/4*9/16, \cf0 /* height */
\par \cf2 		NULL,
\par 		hmenu,
\par 		hInstance,
\par 		NULL);
\par 	ShowWindow(hwnd, SW_MAXIMIZE);	
\par 	\cf0 // SetWindowLong(hwnd, NULL, WS_SIZEBOX);
\par \cf2 	
\par 	\cf1 if\cf2 (hwnd == NULL) \{
\par 		MessageBox(NULL, "Window Creation Failed!","Error!",MB_ICONEXCLAMATION|MB_OK);
\par 		\cf1 return\cf2  0;
\par 	\}
\par 	\cf0 /*
\par 		This is the heart of our program where all input is processed and 
\par 		sent to WndProc. Note that GetMessage blocks code flow until it receives something, so
\par 		this loop will not produce unreasonably high CPU usage
\par 	*/
\par \cf2 	\cf1 while\cf2 (GetMessage(&Msg, NULL, 0, 0) > 0) \{ \cf0 /* If no error is received... */
\par \cf2 		TranslateMessage(&Msg); \cf0 /* Translate key codes to chars if present */
\par \cf2 		DispatchMessage(&Msg); \cf0 /* Send it to WndProc */
\par \cf2 	\}
\par 	\cf1 return\cf2  Msg.wParam;
\par \}
\par 
\par \cf1 int\cf2  CXDoCreateMenu(HMENU hmenu)
\par \{
\par 	
\par 	\cf1 return\cf2  0;
\par \}
\par 
\par \cf1 int\cf2  compress_to_jpg(HDC hdc, LPRECT lprc, \cf1 const\cf2  \cf1 char\cf2 * szFNm)
\par \{
\par 	HDC					hdcMem;
\par 	HBITMAP				hbm = NULL;
\par 	BITMAP				bm;
\par 	HBITMAP				hbmOld = NULL;
\par 	
\par 	HGLOBAL				hImgBytes;
\par 	\cf1 unsigned\cf2  \cf1 char\cf2 *		szImgBytes = \cf1 new\cf2  \cf1 unsigned\cf2  \cf1 char\cf2 ;
\par 	\cf1 unsigned\cf2  \cf1 char\cf2 		szTmp;
\par 	
\par 	jpge::params		paraDef;
\par 	
\par 	hdcMem = CreateCompatibleDC(hdc);
\par 	\cf0 // BUG: Restrict the width of the exported image to be a multiple of 4!!!
\par \cf2 	hbm = CreateCompatibleBitmap(hdc, (lprc->right-lprc->left), lprc->bottom-lprc->top);
\par 	hbmOld = (HBITMAP)SelectObject(hdcMem, hbm);
\par 	SetStretchBltMode(hdc, HALFTONE);
\par 	BitBlt(hdcMem, 0, 0, lprc->right-lprc->left, lprc->bottom-lprc->top, hdc, 0, 0, SRCCOPY);
\par 	GetObject(hbm, \cf1 sizeof\cf2 (BITMAP), &bm);
\par 	\cf0 // Bitmap info:	
\par \cf2 	BITMAPINFOHEADER   bi;
\par     bi.biSize = \cf1 sizeof\cf2 (BITMAPINFOHEADER);    
\par     bi.biWidth = bm.bmWidth;    
\par     bi.biHeight = -bm.bmHeight;  \cf0 // top-down bitmap, in order to be saved as top-down JPG
\par \cf2     bi.biPlanes = 1;    
\par     bi.biBitCount = 24;    
\par     bi.biCompression = BI_RGB;    
\par     bi.biSizeImage = 0;  
\par     bi.biXPelsPerMeter = 0;    
\par     bi.biYPelsPerMeter = 0;    
\par     bi.biClrUsed = 0;    
\par     bi.biClrImportant = 0;
\par     \cf0 // BUG HERE // OUTPUT IMAGE MISALIGNMENT!!! OUTPUT IMAGE MISALIGNMENT!!! OUTPUT IMAGE MISALIGNMENT!!! OUTPUT IMAGE MISALIGNMENT!!!
\par \cf2 	DWORD dwBmpSize = ((bm.bmWidth * bi.biBitCount + 31) / 32) * 4 * bm.bmHeight; \cf0 // misalignment!!! // TO BE CORRECTED!!!!!
\par \cf2 	\cf0 // DWORD dwBmpSize = bm.bmWidth * bm.bmHeight*3; // another misalignment!!!
\par \cf2 	hImgBytes = GlobalAlloc(GHND, dwBmpSize);
\par 	szImgBytes = (\cf1 unsigned\cf2  \cf1 char\cf2 *)GlobalLock(hImgBytes);
\par 	\cf0 // get the image bits in order to be saved in JPEG
\par \cf2  	GetDIBits(hdc, hbm, 0, (UINT)bm.bmHeight, szImgBytes, (LPBITMAPINFO)&bi, DIB_RGB_COLORS);
\par 	\cf0 // now invert red with blue, as our function inverts them self during compression...
\par \cf2 	\cf1 for\cf2 (DWORD i=0; i<dwBmpSize-3-1; i+=3) \cf0 // this is for 3 bits-per-point; last point will be probably not changed!!!
\par \cf2 	\{
\par 		szTmp = szImgBytes[i];
\par 		szImgBytes[i] = szImgBytes[i+2];
\par 		szImgBytes[i+2] = szTmp;
\par 		
\par 	\}
\par 	\cf0 // now save the array of bytes from bitmap in jpeg:
\par \cf2 	jpge::compress_image_to_jpeg_file(szFNm, bm.bmWidth, bm.bmHeight, 3, (\cf1 const\cf2  jpge::uint8*)szImgBytes, paraDef);
\par 	\cf0 // Release allocated memory 
\par \cf2 	GlobalUnlock(hImgBytes);
\par 	GlobalFree(hImgBytes);
\par 	SelectObject(hdcMem, hbmOld);
\par 	DeleteDC(hdcMem);
\par 	
\par 	\cf1 return\cf2  0;
\par \}
\par 
\par 
\par \cf1 int\cf2  decompress_to_dc(HDC hdc, LPRECT lprc, \cf1 const\cf2  \cf1 char\cf2 * szFNm)
\par \{
\par 	\cf0 // variables to do with receiving the bytes from the image
\par \cf2 	\cf1 int\cf2 *				pWidth;			\cf0 // width get from the extracting function
\par \cf2 	\cf1 int\cf2 *				pHeight;		\cf0 // height get from the extracting function
\par \cf2 	\cf1 int\cf2 * 				pActComps;		\cf0 // actual compression returned from the extracting function
\par \cf2 	\cf1 int\cf2  				nReqComps;		\cf0 // required compression sent to the extracting function
\par \cf2 	HGLOBAL				hJpgBytes;		\cf0 // receives the raw-jpg bytes from the file "szFNm" (or "szwFNm" after transforming) 
\par \cf2 	HGLOBAL				hImgBytes;		\cf0 // receives the image bytes
\par \cf2 	\cf1 unsigned\cf2  \cf1 char\cf2 *		szJpgBytes; 	\cf0 // the raw-JPG image stored in memory
\par \cf2 	\cf1 unsigned\cf2  \cf1 char\cf2 *		szImgBytes;		\cf0 // receives the image bytes
\par \cf2 	\cf1 char\cf2 				szTmp;			\cf0 // for By2By operations probably needed 
\par \cf2 	DWORD				dwBmpSize;		\cf0 // the size of the bitmap
\par \cf2 	\cf1 double\cf2 				xResFact = 1;	\cf0 // resize factor
\par \cf2 	\cf0 // variables to do with logging and debugging
\par \cf2 	\cf1 char\cf2 *				szMsg;			\cf0 //
\par \cf2 	szMsg = (\cf1 char\cf2 *)GlobalAlloc(GPTR, 0xff);		\cf0 // this will have to do with debugging...
\par \cf2 	\cf0 //****************************************
\par \cf2 	\cf0 // loading the JPG file from media (hFile from szFNm) to memory in memory (szJpgBytes)
\par \cf2 	\cf0 // REMEMBER TO remove/ replace the conversion from char to wchar in final version, as then all will be wchar
\par \cf2 	LPWSTR				szwFNm = (LPWSTR)GlobalAlloc(GPTR, 0x800);		\cf0 // transform a char* in LPWSTR, for UNICODE
\par \cf2 	mbstowcs(szwFNm, szFNm, 2*strlen(szFNm));
\par 	hJpgBytes = GlobalAlloc(GPTR, 32000000);
\par 	szJpgBytes = (\cf1 unsigned\cf2  \cf1 char\cf2 *)GlobalLock(hJpgBytes);
\par 	
\par 	CXGetJpgBytes(szwFNm, szJpgBytes);
\par 	GlobalUnlock(hJpgBytes);
\par 	CloseHandle(hImgBytes);
\par 	\cf0 //****************************************/
\par \cf2 	\cf0 // now initializing the variables receiving the dimensions of the decompressed picture...
\par \cf2 	pWidth = (\cf1 int\cf2 *)GlobalAlloc(GPTR, \cf1 sizeof\cf2 (\cf1 int\cf2 ));
\par 	pHeight = (\cf1 int\cf2 *)GlobalAlloc(GPTR, \cf1 sizeof\cf2 (\cf1 int\cf2 ));
\par 	pActComps = (\cf1 int\cf2 *)GlobalAlloc(GPTR, \cf1 sizeof\cf2 (\cf1 int\cf2 ));
\par 	
\par 	
\par 	 
\par 	nReqComps = 3; 			\cf0 // 1 = Grayscale; 3 = RGB, 4 = RGBA
\par \cf2 	\cf0 // MessageBox(NULL, "before", NULL, MB_OK); // for debug only
\par \cf2 	\cf0 // get the array of DIBytes from JPEG: decompress from memory instead direct from file??????
\par \cf2 	szImgBytes = (\cf1 unsigned\cf2  \cf1 char\cf2 *)jpgd::decompress_jpeg_image_from_file(szFNm, pWidth, pHeight, pActComps, nReqComps);	
\par 	
\par 	
\par 	\cf0 // correct the colors: invert red with blue
\par \cf2 	\cf1 for\cf2 (DWORD i=0; i<=(*pWidth)*(*pHeight)*3-3; i+=3)
\par 	\{
\par 		\cf1 unsigned\cf2  \cf1 char\cf2  szTmp = szImgBytes[i];
\par 		szImgBytes[i] = szImgBytes[i+2];
\par 		szImgBytes[i+2] = szTmp;
\par 	\}		
\par 	\cf0 // set the dimension of the output rectangle, then invert red with blue and pad the lines to DWORD (HERE THE OUTPUT IMAGE FAILS!!!)
\par \cf2 	dwBmpSize = (*pWidth)*(*pHeight)*3;	
\par 	\cf0 // now set the bitmap info header and bitmap info: (from "Capturing an image" from MSDN)
\par \cf2 	HBITMAP				hbm;
\par 	HBITMAP 			hbmOld;
\par 	BITMAPINFO			bmi;
\par 	\cf0 // Bitmap properties:	
\par \cf2 	ZeroMemory(&bmi, \cf1 sizeof\cf2 (BITMAPINFO));
\par 	bmi.bmiHeader.biSize = \cf1 sizeof\cf2 (BITMAPINFOHEADER);    
\par     bmi.bmiHeader.biWidth = *pWidth;    
\par     bmi.bmiHeader.biHeight = -*pHeight;  
\par     bmi.bmiHeader.biPlanes = 1;    
\par     bmi.bmiHeader.biBitCount = 8*(*pActComps);    
\par     bmi.bmiHeader.biCompression = BI_RGB;    
\par     bmi.bmiHeader.biSizeImage = 0;  
\par     bmi.bmiHeader.biXPelsPerMeter = 0;    
\par     bmi.bmiHeader.biYPelsPerMeter = 0;    
\par     bmi.bmiHeader.biClrUsed = 0;    
\par     bmi.bmiHeader.biClrImportant = 0;
\par 	\cf0 // load image into the hdc:
\par \cf2 	HDC				hdcMem;
\par 	hdcMem = CreateCompatibleDC(hdc);
\par 	hbm = CreateCompatibleBitmap(hdc, *pWidth, *pHeight);
\par 	hbmOld = (HBITMAP)SelectObject(hdcMem, hbm);
\par 	\cf0 // SetStretchBltMode(hdc, HALFTONE);
\par \cf2 	SetDIBits(hdcMem, hbm, 0, *pHeight, szImgBytes, (LPBITMAPINFO)&bmi, DIB_RGB_COLORS);
\par 	free(szImgBytes);
\par 	\cf0 // time to release the resources 
\par \cf2 	SetStretchBltMode(hdc, HALFTONE);
\par 	StretchBlt(hdc, lprc->left, lprc->top, lprc->right-lprc->left, lprc->bottom-lprc->top, hdcMem, 0, 0, *pWidth, *pHeight, SRCCOPY);
\par 	SelectObject(hdcMem, hbmOld);
\par 	DeleteDC(hdcMem);
\par 	\cf0 // release objects and memory, handles aso.
\par \cf2 	GlobalFree(szMsg);
\par 	GlobalFree(pWidth);
\par 	GlobalFree(pHeight);
\par 	GlobalFree(pActComps);
\par 	\cf1 return\cf2  0;
\par \}
\par 
\par \cf1 int\cf2  CXGetJpgBytes(LPCWSTR szwFNm, \cf1 unsigned\cf2  \cf1 char\cf2 * szJpgBytes)
\par \{	\cf0 // gets the JPEG raw file, by flooding the szJpgBytes with the raw data existing into the szwFNm
\par \cf2 	\cf0 // variables to do with storing jpeg image in memory:
\par \cf2 	HANDLE				hFile;			\cf0 // handle to the JPEG file to be opened...
\par \cf2 	DWORD				dwBytesRead;	\cf0 // file size
\par \cf2 	\cf0 // variables to do with logging and debugging
\par \cf2 	LPWSTR				szwMsg;			\cf0 //
\par \cf2 	\cf0 // now the function code itself:
\par \cf2 	
\par 	
\par 	szwMsg = (LPWSTR)GlobalAlloc(GPTR, 0x200);		\cf0 // this will have to do with debugging...
\par \cf2 	hFile = CreateFileW(
\par 						szwFNm, 
\par 						GENERIC_READ,
\par 						0,					\cf0 // no sharing, or what? 
\par \cf2 						NULL,
\par 						OPEN_EXISTING,
\par 						FILE_ATTRIBUTE_NORMAL,
\par 						NULL
\par 						);
\par 	\cf1 if\cf2 (ReadFile(hFile, szJpgBytes, 33, &dwBytesRead, NULL))
\par 	\{
\par 		swprintf(szwMsg, L"Bytes read = %d", dwBytesRead);
\par 		MessageBoxW(NULL, szwMsg, szwFNm, MB_OK);
\par 		
\par 	\}
\par 	\cf1 else
\par \cf2 	\{		
\par 		MessageBoxW(NULL, L"ReadFile() failed!!!!", NULL, MB_OK);
\par 	\}
\par 	CloseHandle(hFile);
\par 	
\par 	\cf1 return\cf2  0;
\par \}
\par 
\par \cf1 int\cf2  CXOpenFile(HWND hwnd, LPRECT lprcOut, LPSTR szFNm)
\par \{
\par 	\cf1 int\cf2 *			pWidth = (\cf1 int\cf2 *)GlobalAlloc(GPTR, \cf1 sizeof\cf2 (\cf1 int\cf2 ));
\par 	\cf1 int\cf2 *			pHeight = (\cf1 int\cf2 *)GlobalAlloc(GPTR, \cf1 sizeof\cf2 (\cf1 int\cf2 ));
\par 	LPRECT			lprc = (LPRECT)GlobalAlloc(GPTR, \cf1 sizeof\cf2 (RECT));
\par 	LPRECT			lprcTop = (LPRECT)GlobalAlloc(GPTR, \cf1 sizeof\cf2 (RECT));
\par 	LPRECT			lprcIn = (LPRECT)GlobalAlloc(GPTR, \cf1 sizeof\cf2 (RECT));
\par 	LPRECT			lprcImg = (LPRECT)GlobalAlloc(GPTR, \cf1 sizeof\cf2 (RECT));
\par 	LPRECT			lprcTxt = (LPRECT)GlobalAlloc(GPTR, \cf1 sizeof\cf2 (RECT));
\par 	BOOL			bExifData = TRUE;
\par 	
\par 	\cf0 // Preparing operations: reading the file EXIF header info, for next steps:
\par \cf2 	HGLOBAL		hexifRes = GlobalAlloc(GHND, \cf1 sizeof\cf2 (EXIFInfo));
\par 	EXIFInfo*	pexifRes = (EXIFInfo*)GlobalLock(hexifRes);
\par 	
\par 	\cf0 // Set the output rectanlgle
\par \cf2 	GetClientRect(hwnd, lprc);
\par 	\cf1 int\cf2  nLat = lprc->bottom-lprc->top-g_nGutter;
\par 	SetRect(lprcTop, lprc->left, lprc->top, lprc->right, lprc->top+g_nGutter);
\par 	SetRect(lprcIn, lprc->left, g_nGutter, lprc->left+nLat, lprc->top+g_nGutter+nLat);
\par 	SetRect(lprcTxt, lprcIn->right, lprcIn->top, lprc->right, lprc->bottom);
\par 	
\par 	\cf1 if\cf2 ((CXGetExifInfoEx(szFNm, pexifRes)==0)&&(TRUE))	\cf0 // if we can parse the EXIF data, we will get it in a structure
\par \cf2 	\{
\par 		*pWidth = pexifRes->ImageWidth;
\par 		*pHeight = pexifRes->ImageHeight;
\par 	\}
\par 	\cf1 else\cf2 	\cf0 // else, no EXIF header, probably JFIF, but however we will get the dimensions with GetImageSize()
\par \cf2 	\{
\par 		GetImageSize(szFNm, pWidth, pHeight);
\par 		bExifData = FALSE;	
\par 	\}
\par 	\cf0 // set now the text on the title / image topmost frame: file name, dimensions, orientation
\par \cf2 	LPWSTR			szwTop = (LPWSTR)GlobalAlloc(GPTR, MAX_PATH*4);
\par 	LPWSTR			szwTxt = (LPWSTR)GlobalAlloc(GPTR, MAX_PATH*8);
\par 	LPWSTR			szwOri = (LPWSTR)GlobalAlloc(GPTR, MAX_PATH*1);
\par 	
\par 	\cf1 unsigned\cf2  \cf1 short\cf2 *	pAngle = (\cf1 unsigned\cf2  \cf1 short\cf2 *)GlobalAlloc(GPTR, \cf1 sizeof\cf2 (\cf1 unsigned\cf2  \cf1 short\cf2 ));
\par 	\cf1 wchar_t\cf2 			wszFNm[0x100];
\par 	mbstowcs(wszFNm, szFNm, strlen(szFNm)+1);
\par 	
\par 	CXOrientation(pexifRes->Orientation, szwOri, pAngle);
\par 	\cf0 // DEBUG MARK##30214
\par \cf2 	\cf0 // MessageBox(NULL, "here", NULL, MB_OK);								// MARK##30214 BUG HERE!!!!!!!!!!!!!!!!!!!!
\par \cf2  
\par 	swprintf(szwTop, L"File: \\"%s\\", Dims: %dx%d, Orientation: %s", wszFNm, *pWidth, *pHeight, szwOri);
\par 	GlobalFree(pAngle);
\par 	GlobalFree(szwOri);
\par 	\cf0 // info text from EXIF data, otherwise, print a message that there no Exif data is available
\par \cf2 	\cf1 if\cf2 (bExifData)	\cf0 // 
\par \cf2 	\{
\par 		CXGetExifInfoText(pexifRes, szwTxt);	\cf0 // Exif info in a format which can be printed
\par \cf2 	\}
\par 	\cf1 else
\par \cf2 	\{
\par 		wcscat(szwTxt, L"\\r\\n\\t\\t - No EXIF data available - ");
\par 	\}
\par 	\cf1 if\cf2 ((*pWidth)/(*pHeight)>=(lprcIn->right-lprcIn->left)/(lprcIn->bottom-lprcIn->top))
\par 	\{
\par 		SetRect(lprcImg, lprcIn->left, lprcIn->top, lprcIn->right, lprcIn->top+(lprcIn->right-lprcIn->left)*(*pHeight)/(*pWidth));
\par 		OffsetRect(lprcImg, 0, ((lprcIn->bottom-lprcIn->top)-(lprcImg->bottom-lprcImg->top))/2);
\par 	\}
\par 	\cf1 else
\par \cf2 	\{
\par 		SetRect(lprcImg, lprcIn->left, lprcIn->top, lprcIn->left+(lprcIn->bottom-lprcIn->top)*(*pWidth)/(*pHeight), lprcIn->bottom);
\par 		OffsetRect(lprcImg, ((lprcIn->right-lprcIn->left)-(lprcImg->right-lprcImg->left))/2, 0);
\par 	\}
\par 	\cf0 // then do the graphic operations:		Declarations
\par \cf2 	PAINTSTRUCT		ps;
\par 	HDC				hdc;
\par 	HBRUSH			hbr, hbrOld;
\par 	\cf0 // then do the graphic operations:		Program
\par \cf2 	BeginPaint(hwnd, &ps);
\par 	hdc = GetDC(hwnd);
\par 	SetBkMode(hdc, TRANSPARENT);									\cf0 // for the text not to have shadow
\par \cf2 	SetTextColor(hdc, RGB(0xd0, 0xd0, 0x40));						\cf0 // gold
\par \cf2 	SelectObject(hdc, CreateSolidBrush(RGB(0x40, 0x20, 0x40)));		\cf0 // dark magenta, for information
\par \cf2 	Rectangle(hdc, lprcTop->left-lprc->left, lprcTop->top-lprc->top, lprcTop->right-lprc->left, lprcTop->bottom-lprc->top);
\par 	DrawTextW(hdc, szwTop, -1, lprcTop, DT_LEFT);					\cf0 // file name, dimensions, orientation in the "toolbar"
\par \cf2 	Rectangle(hdc, lprcTxt->left-lprc->left, lprcTxt->top-lprc->top, lprcTxt->right-lprc->left, lprcTxt->bottom-lprc->top);
\par 	DrawTextW(hdc, szwTxt, -1, lprcTxt, DT_LEFT);
\par 	SelectObject(hdc, CreateSolidBrush(RGB(0x00, 0x00, 0x00)));		\cf0 // full black, for image padding
\par \cf2 	Rectangle(hdc, lprcIn->left-lprc->left, lprcIn->top-lprc->top, lprcIn->right-lprc->left, lprcIn->bottom-lprc->top);
\par 	\cf0 // Function to extract the image from the file "szFNm" and to put it into the form DC:
\par \cf2 	decompress_to_dc(hdc, lprcImg, szFNm);
\par 	\cf0 //
\par \cf2 	ReleaseDC(hwnd, hdc);
\par 	EndPaint(hwnd, &ps);
\par 	
\par 	GlobalFree(szwTop);
\par 	GlobalFree(szwTxt);
\par 	
\par 	GlobalUnlock(hexifRes);
\par 	CloseHandle(hexifRes);
\par 	
\par 	GlobalFree(lprc);
\par 	GlobalFree(lprcTxt);
\par 	GlobalFree(lprcImg);	
\par 	GlobalFree(lprcIn);
\par 	GlobalFree(lprcOut);
\par 	GlobalFree(lprcTop);
\par 	GlobalFree(pWidth);
\par 	GlobalFree(pHeight);
\par 	\cf1 return\cf2  0;
\par \}
\par 
\par \cf1 int\cf2  CXOrientation(\cf1 unsigned\cf2  \cf1 short\cf2  iOrientation, LPWSTR szwOut, \cf1 unsigned\cf2  \cf1 short\cf2  *pAngle)
\par \{
\par 	\cf1 if\cf2 (iOrientation==0)\{	wcscpy(szwOut, L"Unspecified");	*pAngle = 0;	\}		
\par 	\cf1 if\cf2 (iOrientation==1)\{	wcscpy(szwOut, L"Upper Left");	*pAngle = 0;	\}
\par 	\cf1 if\cf2 (iOrientation==3)\{	wcscpy(szwOut, L"Lower Right");	*pAngle = 0;	\}
\par 	\cf1 if\cf2 (iOrientation==6)\{	wcscpy(szwOut, L"Upper Right");	*pAngle = 0;	\}
\par 	\cf1 if\cf2 (iOrientation==8)\{	wcscpy(szwOut, L"Lower Left");	*pAngle = 0;	\}
\par 	\cf1 if\cf2 (iOrientation==9)\{	wcscpy(szwOut, L"Undefined");	*pAngle = 0;	\}
\par 	
\par 	\cf1 return\cf2  0;
\par \}
\par 
\par \cf1 int\cf2  CXNextFileInDirectory(LPTSTR szFNm, \cf1 int\cf2  iStep)
\par \{
\par 	LPTSTR		szDir = (LPTSTR)GlobalAlloc(GPTR, MAX_PATH*2);		\cf0 // the directory-path of the szFNm current file name
\par \cf2 	LPTSTR		szTmp = (LPTSTR)GlobalAlloc(GPTR, MAX_PATH*2);		\cf0 // temporary stored file name
\par \cf2 	LPTSTR		szFnT = (LPTSTR)GlobalAlloc(GPTR, MAX_PATH*2);		\cf0 // stores the szFNm (that are modified already at the begin of the function / mistake!!)
\par \cf2 	HANDLE		hFnY = GlobalAlloc(GHND, MAX_PATH*2*2048);
\par 	LPTSTR		szFnY = (LPTSTR)GlobalLock(hFnY);	\cf0 // all files in the directory get from Dir() function
\par \cf2 	\cf1 int\cf2  		nFound = 0;
\par 	
\par 	strcpy(szFnT, szFNm);
\par 	
\par 	\cf1 int\cf2  i = strlen(szFNm);					\cf0 // WARNING!!!! THIS WILL NOT WORK ON UNICODE OR MBCS FILE NAMES!!!
\par \cf2 	\cf1 while\cf2 ((i>0)&&(szFNm[i---2]!='\\\\'));		\cf0 // WARNING!!!! THIS WILL NOT WORK ON UNICODE OR MBCS FILE NAMES!!!
\par \cf2 	szFNm[i] = 0;
\par 	memcpy(szDir, szFNm, i); 
\par 	memcpy(szTmp, szDir, strlen(szDir));			\cf0 // set it too
\par \cf2 	\cf0 // strcat(szDir, "*.jpg"); 				// WARNING!!!! WARNING!!! WARNING!!!
\par \cf2 	\cf0 // MessageBox(NULL, szFNm, NULL, MB_OK);
\par \cf2 	
\par 	DIR			*dir;				\cf0 // no need for description
\par \cf2 	dirent		*pdir;				\cf0 // 		anyway
\par \cf2 	\cf1 int\cf2 			u = 0;				\cf0 // counts files during dir call 
\par \cf2 	\cf1 int\cf2 			nFiles = 0;			\cf0 // stores the total number of files in the working directory
\par \cf2 	
\par 	dir = opendir(szDir);
\par 	\cf1 int\cf2 	j = 0;
\par 	\cf1 while\cf2 (pdir=readdir(dir))
\par 	\{
\par 		\cf1 if\cf2 (memcmp(pdir->d_name, ".", 1)!=0)	
\par 		\{
\par 			strcat(szTmp, pdir->d_name);	\cf0 // make path, but exclude "." and ".."
\par \cf2 			\cf0 // MessageBox(NULL, szTmp, NULL, MB_OK);
\par \cf2 			memcpy(szFnY+MAX_PATH*2*j, szTmp, strlen(szTmp));		
\par 			\cf0 // MessageBox(NULL, szFnT, szTmp, MB_OK);
\par \cf2 			\cf1 if\cf2 (strcmp(szTmp, szFnT)==0)
\par 			\{
\par 				nFound = j;
\par 			\}
\par 			strcpy(szTmp, szDir);
\par 			j++;
\par 		\}	
\par 	\}
\par 	j--;
\par 	closedir(dir);
\par 	free(pdir);
\par 	\cf0 // prepare the szFNm as modified value to be returned to the program, as next or previous file, depending on iStep
\par \cf2 	\cf1 int\cf2  nCrt = nFound+iStep;
\par 	\cf1 if\cf2 (nCrt>j)	nCrt=nCrt-j;
\par 	\cf1 if\cf2 (nCrt<0)	nCrt=j+nCrt;
\par 	memcpy(szFNm, szFnY+MAX_PATH*2*nCrt, MAX_PATH*2+1);
\par 	\cf0 // MessageBox(NULL, szFnY+MAX_PATH*2*nCrt, NULL, MB_OK);
\par \cf2 	\cf0 // free resources
\par \cf2 	GlobalFree(szFnT);
\par 	GlobalFree(hFnY);
\par 	CloseHandle(hFnY);
\par 	GlobalFree(szTmp);
\par 	GlobalFree(szDir);
\par 	\cf0 // then return to the system
\par \cf2 	\cf1 return\cf2  0;
\par \}
\par 
\par \cf1 int\cf2  CXGetExifInfoText(EXIFInfo* pexifRes, LPWSTR szwTxt)
\par \{
\par 	\cf1 wchar_t\cf2 		wszTmp[512];
\par 	
\par 	\cf0 // header
\par \cf2 	wcscat(szwTxt, L"\\r\\n EXIF Data Information:\\r\\n");
\par 	\cf0 // Description
\par \cf2 	wcscat(szwTxt, L"\\r\\n\\t Description: ");
\par 	mbstowcs(wszTmp, pexifRes->ImageDescription.c_str(), strlen(pexifRes->ImageDescription.c_str())+1);
\par 	wcscat(szwTxt, wszTmp);
\par 	\cf0 // Copyright
\par \cf2 	wcscat(szwTxt, L"\\r\\n\\t Copyright: ");
\par 	mbstowcs(wszTmp, pexifRes->Copyright.c_str(), strlen(pexifRes->Copyright.c_str())+1);
\par 	wcscat(szwTxt, wszTmp);
\par 	\cf0 // Make and model
\par \cf2 	wcscat(szwTxt, L"\\r\\n\\t Camera: ");
\par 	mbstowcs(wszTmp, pexifRes->Model.c_str(), strlen(pexifRes->Model.c_str())+1);
\par 	wcscat(szwTxt, wszTmp);
\par 	wcscat(szwTxt, L", Manufacturer: ");
\par 	mbstowcs(wszTmp, pexifRes->Make.c_str(), strlen(pexifRes->Make.c_str())+1);
\par 	wcscat(szwTxt, wszTmp);
\par 	\cf0 // Software
\par \cf2 	wcscat(szwTxt, L"\\r\\n\\t Software used: ");
\par 	mbstowcs(wszTmp, pexifRes->Software.c_str(), strlen(pexifRes->Software.c_str())+1);
\par 	wcscat(szwTxt, wszTmp);
\par 	\cf0 // Date and time picture taken, digitized, original sub-second
\par \cf2 	wcscat(szwTxt, L"\\r\\n\\t Date & Time Picture Taken: ");
\par 	mbstowcs(wszTmp, pexifRes->DateTimeOriginal.c_str(), strlen(pexifRes->DateTimeOriginal.c_str())+1);
\par 	wcscat(szwTxt, wszTmp);
\par 	wcscat(szwTxt, L"\\r\\n\\t Date & Time Picture Digitized: ");
\par 	mbstowcs(wszTmp, pexifRes->DateTimeDigitized.c_str(), strlen(pexifRes->DateTimeDigitized.c_str())+1);
\par 	wcscat(szwTxt, wszTmp);
\par 	wcscat(szwTxt, L"\\r\\n\\t Date & Time Sub-Second Original: ");
\par 	mbstowcs(wszTmp, pexifRes->SubSecTimeOriginal.c_str(), strlen(pexifRes->SubSecTimeOriginal.c_str())+1);
\par 	wcscat(szwTxt, wszTmp);
\par 	\cf0 // other data...
\par \cf2 	wcscat(szwTxt, L"\\r\\n\\t : ");
\par 	mbstowcs(wszTmp, pexifRes->Copyright.c_str(), strlen(pexifRes->Copyright.c_str())+1);
\par 	wcscat(szwTxt, wszTmp);
\par 	
\par 	\cf0 /*
\par 	pexifRes->ImageHeight			// unsigned
\par 	pexifRes->ImageWidth			// unsigned
\par 	pexifRes->BitsPerSample 		// unsigned short
\par 	pexifRes->ByteAlign				// char
\par 
\par 	pexifRes->ExposureBiasValue		// double
\par 	pexifRes->ExposureTime			// double
\par 	pexifRes->Flash					// char			// 0 = no flash, 1 = flash used
\par 	pexifRes->FNumber				// double		// F/stop
\par 	pexifRes->FocalLength			// double
\par 	pexifRes->FocalLengthIn35mm		// unsigned short
\par 	
\par 	
\par 	pexifRes->ISOSpeedRatings		// unsigned short
\par 	pexifRes->MeteringMode			// unsigned short
\par 	
\par 	pexifRes->ShutterSpeedValue		// double
\par 	pexifRes->SubjectDistance		// double
\par 	
\par 
\par 	*/
\par \cf2 	
\par 	
\par 	\cf1 return\cf2  wcslen(szwTxt);
\par \}
\par 
\par \cf1 int\cf2  CXTextWithShadow(
\par 					HDC hdc, 
\par 					LPRECT lprcBmp, 
\par 					LPCWSTR szText, 
\par 					UINT nMLine, 
\par 					UINT nSize, 
\par 					UINT nRow, 
\par 					UINT nCol, 
\par 					UINT nShadow, 
\par 					UINT nMode
\par 					)
\par \{	\cf0 // make it on another DC then SRCCOPY
\par \cf2 	\cf1 const\cf2  \cf1 double\cf2  	xGut = 0.05;		\cf0 // gutter (left, right, top, bottom= the same, as well as 
\par \cf2 										\cf0 //  multiplication factor for the 
\par \cf2 	\cf0 // NOTE: nMode> 0: Writes direct into the "hdc" as argument, when FALSE, first in an a new HDC then combines the two
\par \cf2 	
\par 	LPRECT			lprcText;
\par 	HFONT 			hf;
\par 	HFONT			hfOld;
\par 	\cf1 long\cf2  			lfHeight;
\par 	UINT			nTxtPara;
\par 
\par 	HDC				hdcX;
\par 	SIZE			sizBmp;
\par 	
\par 	sizBmp.cx = lprcBmp->right-lprcBmp->left;
\par 	sizBmp.cy = lprcBmp->bottom-lprcBmp->top;
\par 	nTxtPara = DT_SINGLELINE*(nMLine==0)|DT_WORDBREAK*(nMLine>0)|
\par 				((nRow==1)*(DT_TOP))|((nRow==2)*(DT_VCENTER))|((nRow==3)*(DT_BOTTOM))|
\par 				((nCol==1)*(DT_LEFT))|((nCol==2)*(DT_CENTER))|((nCol==3)*(DT_RIGHT));
\par 	\cf0 // a new full HDC is created, where the text will be initially printed, then copied into the destination DC:
\par \cf2 	HDC				hdcMemTxt;
\par 	HBITMAP			hbmMemTxt;
\par 	HBITMAP			hbmMemOld;
\par 	\cf1 if\cf2 (nMode)
\par 	\{
\par 		hdcMemTxt = CreateCompatibleDC(hdc);
\par 		hbmMemTxt = CreateCompatibleBitmap(hdc, sizBmp.cx, sizBmp.cy);
\par 		hbmMemOld = (HBITMAP)SelectObject(hdcMemTxt, hbmMemTxt);
\par 		hdcX = hdcMemTxt;
\par 	\}
\par 	\cf1 else
\par \cf2 	\{
\par 		hdcX = hdc;
\par 	\}
\par 	\cf0 // getting the font parameters:
\par \cf2 	\cf0 // lfHeight = -MulDiv(24, GetDeviceCaps(hdc, LOGPIXELSY), 36);	// no really needed to be aligned with the pixels...
\par \cf2 	lfHeight = nSize*xGut*(sizBmp.cy>(16/9)*sizBmp.cx?sizBmp.cy:sizBmp.cx)/10;
\par 	hf = CreateFont(lfHeight, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "Verdana");
\par 	lprcText = (LPRECT)GlobalAlloc(GPTR, \cf1 sizeof\cf2 (RECT));
\par 	hfOld = (HFONT)SelectObject(hdcX, hf);
\par 	\cf0 // drawing the text:
\par \cf2 	SetBkMode(hdcX, TRANSPARENT);
\par 	SetRect(lprcText, xGut*sizBmp.cy, xGut*sizBmp.cy, sizBmp.cx-xGut*sizBmp.cy, sizBmp.cy-xGut*sizBmp.cy);
\par 	\cf0 // // drawing the shadow first, then the text self
\par \cf2 	\cf1 switch\cf2 (nShadow)\{
\par 		\cf1 case\cf2  1:
\par 		\{
\par 			SetTextColor(hdcX, RGB(64, 64, 64));
\par 			DrawTextW(hdcX, szText, -1, lprcText, nTxtPara);
\par 			OffsetRect(lprcText, -lfHeight*0.1, -lfHeight*0.1);				\cf0 // for the next...
\par \cf2 			\cf1 break\cf2 ;
\par 		\}
\par 		\cf1 case\cf2  2:		\cf0 // TO BE REVISED - IT NOT WORKS CORRECTLY!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
\par \cf2 		\{
\par 			\cf1 float\cf2  r = 2*lfHeight*0.1, th = 0;		\cf0 // to rotate the text rectangle around.
\par \cf2 			\cf1 float\cf2  x0 = 0, y0 = 0, x = r*cos(th), y = r*cos(th); 
\par 			\cf1 for\cf2 (th=PI/4; th<=4*PI; th+=PI/4)
\par 			\{
\par 				x0 = x; 	y0 = y; 
\par 				\cf1 if\cf2 (th>2*PI)\{
\par 					r = lfHeight*0.1;				
\par 					SetTextColor(hdcX, RGB(32, 32, 32));
\par 				\}
\par 				OffsetRect(lprcText, x-x0, y-y0);		\cf0 // offset the textout rect to create shadow around-and-around
\par \cf2 				x = r*cos(th); 			y = r*cos(th); 
\par 				DrawTextW(hdcX, szText, -1, lprcText, nTxtPara);
\par 			\}
\par 			OffsetRect(lprcText, -r/2, 0);			\cf0 // bring the rectangle in the center of the "aura"
\par \cf2 			\cf1 break\cf2 ;
\par 		\}
\par 		
\par 	\}
\par 	\cf0 // then the text self
\par \cf2 	SetTextColor(hdcX, RGB(204, 204, 80));
\par 	\cf1 if\cf2 (nMode)
\par 	\{
\par 		SetTextColor(hdcX, RGB(32, 64, 128));
\par 	\}
\par 	DrawTextW(hdcX, szText, -1, lprcText, nTxtPara);
\par 	\cf0 // when indirect, copy the text-image from memory in the output image:
\par \cf2 	\cf1 if\cf2 (nMode)
\par 	\{
\par 		StretchBlt(hdc, 0, 0, sizBmp.cx, sizBmp.cy, hdcX, 0, 0, sizBmp.cx, sizBmp.cy, SRCPAINT);
\par 		\cf0 // AlphaBlend();		// ?????????????
\par \cf2 	\}
\par 	\cf0 // Closing operations
\par \cf2 	SelectObject(hdcX, hfOld);
\par 	GlobalFree(lprcText);
\par 	\cf1 if\cf2 (nMode)
\par 	\{
\par 		SelectObject(hdcMemTxt, hbmMemOld);
\par 		DeleteObject(hbmMemTxt);
\par 		DeleteDC(hdcMemTxt);
\par 	\}
\par 	\cf1 else
\par \cf2 	\{
\par 		hdc = hdcX;
\par 	\}
\par 	\cf1 return\cf2  0;
\par \}
\par 
\par 
\par \cf1 int\cf2  CXModifyJpgImage(HWND hwnd, \cf1 double\cf2  xNewWidth, \cf1 double\cf2  yNewHeight)
\par \{
\par 	\cf0 // decompresses the JPG image from the "szFNmInp" file, 
\par \cf2 	\cf0 //	then modifies the size, colours, 
\par \cf2 	\cf0 // 	then shows a preview into the window handled by "hwnd", 
\par \cf2 	\cf0 //
\par \cf2 	HDC					hdc;
\par 	HDC					hdcMem;
\par 	HBITMAP				hbm;
\par 	HBITMAP				hbmOld;
\par 	LPSTR				szFNm;			\cf0 // file name = all filest to process...
\par \cf2 	LPSTR				szFNI;			\cf0 // file name = Input
\par \cf2 	LPSTR				szFNO; 			\cf0 // file name = Output
\par \cf2 	LPRECT				lprcX;			\cf0 // for debug only
\par \cf2 	\cf0 // jpeg file dimensions: 
\par \cf2 	\cf1 int\cf2 *				pWidth 		= (\cf1 int\cf2 *)GlobalAlloc(GPTR, \cf1 sizeof\cf2 (\cf1 int\cf2 ));
\par 	\cf1 int\cf2 *				pHeight 	= (\cf1 int\cf2 *)GlobalAlloc(GPTR, \cf1 sizeof\cf2 (\cf1 int\cf2 ));
\par 	\cf1 int\cf2 					xImgW, yImgH; 	\cf0 // same as the above
\par \cf2 	\cf1 unsigned\cf2  \cf1 short\cf2 		nOrientation;	\cf0 // EXIF orientation tag
\par \cf2 	\cf0 // debug and info variables:
\par \cf2 	\cf1 char\cf2 *				szMsg = (\cf1 char\cf2 *)GlobalAlloc(GPTR, MAX_PATH);	
\par 	LPWSTR				szOut = (LPWSTR)GlobalAlloc(GPTR, 0x200);		\cf0 // -- displays some text
\par \cf2 	LPWSTR				szOuu = (LPWSTR)GlobalAlloc(GPTR, 0x200);		\cf0 // -- displays geolocation
\par \cf2 	LPWSTR				szOuv = (LPWSTR)GlobalAlloc(GPTR, 0x800);		\cf0 // -- display full available exif information
\par \cf2 	
\par 	szFNm = (LPTSTR)GlobalAlloc(GPTR, (MAX_PATH+1)*0x400+1);		\cf0 // for many files...
\par \cf2 	\cf1 if\cf2 (ProvideTheFileName(NULL, szFNm)==3604)
\par 	\{
\par 		szFNI = (LPTSTR)GlobalAlloc(GPTR, MAX_PATH);			\cf0 // the current file input
\par \cf2 		szFNO = (LPTSTR)GlobalAlloc(GPTR, MAX_PATH);			\cf0 // the current file output
\par \cf2 		\cf0 // here code to get the FNI (as well as FNO) from FNm: 
\par \cf2 		memcpy(szFNI, szFNm, strlen(szFNm));
\par 		
\par 		\cf1 int\cf2  i = strlen(szFNm);					\cf0 // WARNING!!!! THIS WILL NOT WORK ON UNICODE OR MBCS FILE NAMES!!!
\par \cf2 		\cf1 while\cf2 ((i>0)&&(szFNm[i---2]!='\\\\'));		\cf0 // WARNING!!!! THIS WILL NOT WORK ON UNICODE OR MBCS FILE NAMES!!!
\par \cf2 		memcpy(szFNO, szFNI, i); strcat(szFNO, "TT_"); strcat(szFNO, szFNm+i);	\cf0 // WARNING!!!! WARNING!!! WARNING!!!
\par \cf2 		\cf0 // Preparing operations: reading the file EXIF header info, for next steps:
\par \cf2 		HGLOBAL		hexifRes = GlobalAlloc(GHND, \cf1 sizeof\cf2 (EXIFInfo));
\par 		EXIFInfo*	pexifRes = (EXIFInfo*)GlobalLock(hexifRes);
\par 		\cf1 if\cf2 (CXGetExifInfoEx(szFNI, pexifRes)==0)
\par 		\{
\par 			xImgW = pexifRes->ImageWidth;
\par 			yImgH = pexifRes->ImageHeight;
\par 			nOrientation = pexifRes->Orientation;
\par 			\cf0 // prints the scan date...
\par \cf2 			\cf1 wchar_t\cf2 		wszTmp[512];		\cf0 // this will convert the character of bytes-text to wide-character text, necessary to display the right text!!!
\par \cf2 			mbstowcs(wszTmp, pexifRes->DateTimeOriginal.c_str(), strlen(pexifRes->DateTimeOriginal.c_str())+1);
\par 			memcpy(szOut, wszTmp, 512);
\par 			swprintf(szOut, L"%s", wszTmp);
\par 			\cf0 // prints the GPS Information:
\par \cf2 			\cf1 if\cf2 ((pexifRes->GeoLocation.Latitude!=0)||(pexifRes->GeoLocation.Longitude!=0))	\cf0 // if it exists, ...
\par \cf2 			\{	\cf0 // no need for comments: this retrieves the GPS information recorded in the picture at shooting time
\par \cf2 				swprintf(szOuu, L"Location: %f%c (%02.0f%c %02.0f%c %02.3f%c) %c, %f%c (%02.0f%c %02.0f%c %02.3f%c) %c, %.0f m", 
\par 			  					pexifRes->GeoLocation.Latitude,0x00b0, 
\par 			          			pexifRes->GeoLocation.LatComponents.degrees, 0x00b0, 
\par 			          			pexifRes->GeoLocation.LatComponents.minutes, '\\'', 
\par 			          			pexifRes->GeoLocation.LatComponents.seconds, '\\"', 
\par 			          			pexifRes->GeoLocation.LatComponents.direction, 
\par 			  					pexifRes->GeoLocation.Longitude,0x00b0, 
\par 			          			pexifRes->GeoLocation.LonComponents.degrees, 0x00b0, 
\par 			          			pexifRes->GeoLocation.LonComponents.minutes, '\\'', 
\par 			          			pexifRes->GeoLocation.LonComponents.seconds, '\\"', 
\par 			          			pexifRes->GeoLocation.LonComponents.direction, 
\par 			          			pexifRes->GeoLocation.Altitude);
\par 			\}
\par 			
\par 		\}
\par 		\cf1 else
\par \cf2 		\{	\cf0 // get at least the image dimensions:
\par \cf2 			GetImageSize(szFNm, &xImgW, &yImgH);
\par 		\}
\par 		GlobalUnlock(hexifRes);
\par 		GlobalFree(hexifRes);
\par 		\cf0 // wsprintf(szMsg, "%d, %d\\r\\n%s\\r\\n%s", xImgW, yImgH, szFNI, szFNO);		// for debug (and for information only)
\par \cf2 		\cf0 // MessageBox(NULL, szMsg, NULL, MB_OK);									// for debug (and for information only)
\par \cf2 		\cf0 // here code to resize the image: setting the rectangle of the resized image:
\par \cf2 		\cf1 if\cf2 ((xNewWidth==0)&&(yNewHeight==0))
\par 		\{
\par 			xNewWidth = xImgW;
\par 			yNewHeight = yImgH;
\par 		\}
\par 		\cf1 else
\par \cf2 		\{
\par 			\cf1 if\cf2 (xNewWidth==0)	xNewWidth = yNewHeight*xImgW/yImgH;		\cf0 // the dimension left zero, will be calculated based on preserving the original aspect ratio
\par \cf2 			\cf1 if\cf2 (yNewHeight==0)	yNewHeight = xNewWidth*yImgH/xImgW;		\cf0 //		... of the original image, if no one is zero the result will be stretched, 
\par \cf2 		\}
\par 		lprcX = (LPRECT)GlobalAlloc(GPTR, \cf1 sizeof\cf2 (RECT));
\par 		lprcX->left = 0;		
\par 		lprcX->right = xNewWidth;				\cf0 // thise means: if both newWidht and newHeight are zero, then the original size will be used!
\par \cf2 		lprcX->top = 0;												
\par 		lprcX->bottom = yNewHeight;			
\par 		\cf0 // code to prepare the (memory- and screen-) DC for the graphic operations
\par \cf2 		hdc = GetDC(NULL);
\par 		hdcMem = CreateCompatibleDC(hdc);
\par 		hbm = CreateCompatibleBitmap(hdc, xNewWidth, yNewHeight); 	\cf0 // here the new dimensions of the bitmap or the resize goes crazy - never known why!!!
\par \cf2 		hbmOld = (HBITMAP)SelectObject(hdcMem, hbm);
\par   		\cf0 // now the operation self:
\par \cf2 		decompress_to_dc(hdcMem, lprcX, szFNI);
\par 		\cf0 //////////////////////////////////////////////////////////////////////
\par \cf2 		\cf0 // here code to show preview on the form...	// it cannot be prewiewed on form, why??? (see version A30??)	
\par \cf2 		
\par 		
\par 		\cf0 //////////////////////////////////////////////////////////////////////
\par \cf2 		\cf0 // end of just for preview on form...
\par \cf2 		\cf0 // write some text on the output image:		
\par \cf2 		CXTextWithShadow(hdcMem, lprcX, szOut, 0, 3, 3, 3, 1, 0);
\par 		CXTextWithShadow(hdcMem, lprcX, L"SAMPLE PICTURE ", 0, 24, 2, 2, 0, 1);
\par 		CXTextWithShadow(hdcMem, lprcX, szOuu, 0, 3, 1, 3, 1, 0);		\cf0 // problem: LPWSTR conversion: SOLVED with "mbtowcs()" see above!!!
\par \cf2 		\cf0 // then save the jpg file:
\par \cf2 		compress_to_jpg(hdcMem, lprcX, szFNO);
\par 		\cf0 // and finally, closing operations:
\par \cf2 		SelectObject(hdcMem, hbmOld);
\par 		GlobalFree(lprcX);
\par 		CloseHandle(hbm);
\par 		CloseHandle(hbmOld);
\par 		DeleteDC(hdcMem);
\par 		ReleaseDC(NULL, hdc);
\par 		GlobalFree(szFNI);
\par 		GlobalFree(szFNO);
\par 
\par 	\}
\par 	\cf1 else
\par \cf2 	\{
\par 		\cf1 return\cf2  -23;
\par 	\}
\par 	GlobalFree(szFNm);
\par 	GlobalFree(pWidth);
\par 	GlobalFree(pHeight);
\par 	GlobalFree(szOuv);
\par 	GlobalFree(szOuu);
\par 	GlobalFree(szOut);
\par 	GlobalFree(szMsg);
\par 	\cf1 return\cf2  0;
\par \}
\par 
\par 
\par \cf1 void\cf2  test__JPG2HWND(HWND hwnd)
\par \{
\par 	PAINTSTRUCT 		ps;
\par 	HDC					hdc;
\par 	RECT				rcClient;
\par 	LPRECT				lprcDes;
\par 	
\par 	lprcDes = (LPRECT)GlobalAlloc(GPTR, \cf1 sizeof\cf2 (RECT));
\par 	BeginPaint(hwnd, &ps);
\par 	hdc = GetDC(hwnd);
\par 	
\par 	GetClientRect(hwnd, &rcClient);
\par 	
\par 	decompress_to_dc(hdc, lprcDes, "c:\\\\tmp\\\\input.jpg");
\par 	
\par 	ReleaseDC(hwnd, hdc);
\par 	EndPaint(hwnd, &ps);
\par 	GlobalFree(lprcDes);
\par 	
\par \}
\par 
\par \cf1 void\cf2  test__HWND2JPG(HWND hwnd)
\par \{
\par 	
\par 	PAINTSTRUCT		ps;
\par 	HDC				hdc;
\par 	RECT			rcClient;
\par 	\cf1 char\cf2 *			szMsg = \cf1 new\cf2  \cf1 char\cf2 ;
\par 	
\par 	BeginPaint(hwnd, &ps);
\par 	hdc = GetDC(hwnd);
\par 	GetClientRect(hwnd, &rcClient);
\par 
\par 	compress_to_jpg(hdc, &rcClient, "c:\\\\tmp\\\\output.jpg");
\par 	
\par 	ReleaseDC(hwnd, hdc);
\par 	EndPaint(hwnd, &ps);
\par 		
\par \}
\par 
\par 
\par \cf1 void\cf2  CatPath(\cf1 char\cf2  * BasePath, \cf1 const\cf2  \cf1 char\cf2  * FilePath)
\par \{	\cf0 // from "http://www.sentex.net/~mwandel/jhead/"
\par \cf2 	\cf1 const\cf2  \cf1 char\cf2  slash = '\\\\';
\par     \cf1 int\cf2  l;
\par     
\par     l = strlen(BasePath);
\par     \cf1 if\cf2  (FilePath[1] == ':')\{
\par         \cf0 // Its a windows absolute path.
\par \cf2         l = 0;
\par     \}
\par     \cf1 if\cf2  (FilePath[0] == slash || FilePath[0] == '.' || l == 0)\{
\par         \cf0 // Its an absolute path, or there was no base path.
\par \cf2         strcpy(BasePath, FilePath);
\par         \cf1 return\cf2 ;
\par     \}
\par     \cf1 if\cf2  (BasePath[l-1] != slash)\{
\par         BasePath[l++] = slash;
\par         BasePath[l] = 0;
\par     \}
\par     strcat(BasePath, FilePath);
\par     \cf0 // Note that the combined path may contains things like "foo/../bar".   We assume
\par \cf2     \cf0 // that the filesystem will take care of these.
\par \cf2 \}
\par 
\par 
\par \cf1 void\cf2  SaveFormImageOnMem(HWND hwnd, BOOL bUpd)
\par \{
\par 	\cf0 // this function saves the image represented by the HDC of hwnd into the global memory image-handle g_hbm,
\par \cf2 	\cf0 // 		if bUpd = FALSE, and restores it from this memory when bUpd = TRUE
\par \cf2 	PAINTSTRUCT			ps;
\par 	HDC					hdc;		\cf0 // a...
\par \cf2 	HDC					hdcMem;
\par 	\cf0 // HBITMAP				hbm;	//   -replaced with the global variable g_hbm ... must be global to restore the content
\par \cf2 	HBITMAP				hbmOld;		\cf0 // ...a
\par \cf2     RECT				rcClient;	\cf0 //
\par 
\par \cf2     \cf0 // // opening procedure...
\par \cf2 	GetClientRect(hwnd, &rcClient);
\par 	\cf1 if\cf2 (bUpd) BeginPaint(hwnd, &ps);
\par 	hdc = GetDC(hwnd);
\par 	hdcMem = CreateCompatibleDC(hdc);				\cf0 //
\par \cf2 	\cf1 if\cf2 (!bUpd)
\par 		g_hbm = CreateCompatibleBitmap(hdc, rcClient.right-rcClient.left, rcClient.bottom-rcClient.top);
\par 	hbmOld = (HBITMAP)SelectObject(hdcMem, g_hbm);
\par 	\cf0 // // saving or updating procedure
\par \cf2 	\cf1 if\cf2 (bUpd)	\cf0 // restoring the content of the DC of the client-area of the window from memory...
\par \cf2 		BitBlt(hdc, 0, 0, rcClient.right-rcClient.left, rcClient.bottom-rcClient.top, hdcMem, 0, 0, SRCCOPY);
\par 	\cf1 else\cf2 		\cf0 // saving the content of the DC of the client-area of the window into the memory...
\par \cf2 		BitBlt(hdcMem, 0, 0, rcClient.right-rcClient.left, rcClient.bottom-rcClient.top, hdc, 0, 0, SRCCOPY);
\par 	\cf0 // // closing procedure
\par \cf2 	SelectObject(hdcMem, hbmOld);
\par 	DeleteDC(hdcMem);
\par 	ReleaseDC(hwnd, hdc);
\par 	\cf1 if\cf2 (bUpd) EndPaint(hwnd, &ps);
\par 
\par \}
\par 
\par 
\par DWORD ProvideTheFileName(HWND hwnd, LPSTR szFNm)
\par \{
\par 	OPENFILENAME 	ofn;       	\cf0 // common dialog box structure
\par \cf2     
\par     \cf0 // Initialize OPENFILENAME
\par \cf2     ZeroMemory(&ofn, \cf1 sizeof\cf2 (ofn));
\par     ofn.lStructSize = \cf1 sizeof\cf2 (ofn);
\par     ofn.hwndOwner = hwnd;
\par     ofn.lpstrFile = szFNm;
\par     ofn.nMaxFile = (MAX_PATH+1)*0x400+1;
\par     ofn.lpstrFilter = "JPEG Files (*.jpg)\\0*.jpg\\0All Files (*.*)\\0*.*\\0";
\par     ofn.nFilterIndex = 1;
\par     ofn.lpstrFileTitle = NULL;
\par     ofn.nMaxFileTitle = 0;
\par     ofn.lpstrInitialDir = NULL;
\par 	ofn.Flags = OFN_EXPLORER|OFN_PATHMUSTEXIST|OFN_FILEMUSTEXIST;
\par     \cf0 // Display the Open dialog box.
\par \cf2 	\cf1 if\cf2  (GetOpenFileName(&ofn)==TRUE)
\par     \{
\par         \cf0 // MessageBox(NULL, "here!!!", NULL, MB_OK);			// for debug only...
\par \cf2 		\cf1 return\cf2  3604;
\par     \}
\par     \cf1 else
\par \cf2     \{
\par     	\cf1 if\cf2 (CommDlgExtendedError()!=0)
\par     	\{
\par     		MessageBox(NULL, "File open error", "Message from programmer dude", MB_OK|MB_ICONERROR);
\par     	\}
\par     \}
\par 	\cf1 return\cf2  1137;
\par \}
\par 
\par 
\par \cf1 int\cf2  CXLogPrint(\cf1 const\cf2  \cf1 char\cf2 * szPat, \cf1 int\cf2  iPos, \cf1 const\cf2  \cf1 char\cf2 * szWhat, BOOL bNew)
\par \{
\par 	HANDLE 				hFOut;				\cf0 // output file		
\par \cf2 	\cf1 char\cf2 				*szFNm = \cf1 new\cf2  \cf1 char\cf2 ;	\cf0 // builds the file name based on the pattern szPat;
\par \cf2 	\cf1 char\cf2 				*szMsg = \cf1 new\cf2  \cf1 char\cf2 ;	\cf0 // a message to ...
\par \cf2 	DWORD				dwBytesRead;		\cf0 // 
\par \cf2 	
\par 	szFNm = (\cf1 char\cf2 *)GlobalAlloc(GPTR, MAX_PATH);
\par 	szMsg = (\cf1 char\cf2 *)GlobalAlloc(GPTR, MAX_PATH);
\par 	wsprintf(szFNm, szPat, iPos);
\par 	\cf0 // hFind = FindFirstFile(szFNm, &fndDat);
\par \cf2 	\cf1 while\cf2 (CXFileExists(szFNm))
\par 	\{
\par 		iPos+=(iPos<10000);
\par 		wsprintf(szFNm, szPat, iPos);		
\par 	\}
\par 	\cf1 if\cf2 (!bNew)
\par 	\{
\par 		iPos--;
\par 		wsprintf(szFNm, szPat, iPos);
\par 	\}
\par 	hFOut = CreateFile(szFNm, GENERIC_WRITE, 7, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
\par 	\cf0 // WARNING!!! the 3rd parameter of "CreateFile()" must be 7 if you want to append something to it!!!!!! WARNING!!!
\par \cf2 	\cf1 if\cf2 (hFOut==INVALID_HANDLE_VALUE)
\par 	\{
\par 		\cf0 // wsprintf(szMsg, "Last Error = %d", GetLastError());
\par \cf2 		wsprintf(szMsg, "could not create/ write in file:\\r\\n %s", szFNm);
\par 		MessageBox(NULL, szMsg, szFNm, MB_OK);
\par 	\}
\par 	\cf1 else
\par \cf2 	\{
\par 		\cf0 // wsprintf(szMsg, "bytes = %d", dwBytes);
\par \cf2 		\cf1 if\cf2 (!bNew)
\par 		\{
\par 			SetFilePointer(hFOut, 0, 0, FILE_END);
\par 			\cf0 // // LockFileEx(hFOut, LOCKFILE_FAIL_IMMEDIATELY, 0, 0, 0, NULL);
\par \cf2 		\}
\par 		WriteFile(hFOut, szWhat, strlen(szWhat), &dwBytesRead, NULL);
\par 		\cf1 return\cf2  iPos;			\cf0 // on success
\par \cf2 	\}
\par 	
\par 	CloseHandle(hFOut);
\par 	GlobalFree(szFNm);
\par 	GlobalFree(szMsg);
\par 	\cf1 return\cf2  0;
\par \}
\par 
\par \cf1 inline\cf2  \cf1 bool\cf2  CXFileExists(\cf1 const\cf2  \cf1 char\cf2  *szFNm)
\par \{	\cf0 // from "http://stackoverflow.com/questions/12774207/fastest-way-to-check-if-a-file-exist-using-standard-c-c11-c"
\par \cf2 	\cf1 struct\cf2  stat buffer;   
\par 	\cf1 return\cf2  (stat (szFNm, &buffer) == 0); \cf0 // the fastest piece of code in the history that check if a file already exists!!!
\par \cf2 \}
\par 
\par 
\par \cf1 int\cf2  CXGetExifInfoEx(LPCSTR szFNm, EXIFInfo* pexifRes)
\par \{
\par 	FILE *fp = fopen(szFNm, "rb");
\par   \cf1 if\cf2  (!fp) \{ 
\par     printf("Can't open file.\\n"); 
\par     \cf1 return\cf2  -1; 
\par   \}
\par   fseek(fp, 0, SEEK_END);
\par   \cf1 unsigned\cf2  \cf1 long\cf2  fsize = ftell(fp);
\par   rewind(fp);
\par   HANDLE 			hBuf = GlobalAlloc(GHND, fsize);
\par   \cf1 unsigned\cf2  \cf1 char\cf2 * 	szBuf = (\cf1 unsigned\cf2  \cf1 char\cf2 *)GlobalLock(hBuf);
\par   \cf1 if\cf2  (fread(szBuf, 1, fsize, fp) != fsize) \{
\par     printf("Can't read file.\\n");
\par     GlobalUnlock(hBuf);
\par     CloseHandle(hBuf);
\par     MessageBoxW(NULL, L"Cannot read the file or the EXIF information in the file", L"Message from programmer dude!", MB_OK);
\par     \cf1 return\cf2  -8;
\par   \}
\par   fclose(fp);
\par   \cf0 // Parse EXIF
\par \cf2   EXIFInfo result;
\par   \cf1 int\cf2  code = result.parseFrom(szBuf, fsize);
\par   GlobalUnlock(hBuf);
\par   CloseHandle(hBuf);
\par   \cf1 if\cf2  (code) \{
\par     \cf0 // MessageBoxW(NULL, L"Error parsing EXIF: code %%d\\n \\"code\\"", L"CXGetExifInfoEx()", MB_OK);
\par \cf2     \cf1 return\cf2  -3;
\par   \}
\par 	memcpy(pexifRes, &result, \cf1 sizeof\cf2 (EXIFInfo));
\par 	\cf1 return\cf2  0;
\par \}
\par 
\par 
\par \cf1 bool\cf2  GetImageSize(\cf1 const\cf2  \cf1 char\cf2  *fn, \cf1 int\cf2  *x,\cf1 int\cf2  *y)
\par \{ \cf0 // thanks to: "http://www.cplusplus.com/forum/beginner/45217/" for this function
\par \cf2     FILE *f=fopen(fn,"rb");
\par     \cf1 if\cf2  (f==0) \cf1 return\cf2  \cf1 false\cf2 ;
\par     fseek(f,0,SEEK_END);
\par     \cf1 long\cf2  len=ftell(f);
\par     fseek(f,0,SEEK_SET);
\par     \cf1 if\cf2  (len<24) \{
\par         fclose(f);
\par         \cf1 return\cf2  \cf1 false\cf2 ;
\par         \}
\par 		\cf0 // cout << fn << endl;
\par \cf2   \cf0 // Strategy:
\par \cf2   \cf0 // reading GIF dimensions requires the first 10 bytes of the file
\par \cf2   \cf0 // reading PNG dimensions requires the first 24 bytes of the file
\par \cf2   \cf0 // reading JPEG dimensions requires scanning through jpeg chunks
\par \cf2   \cf0 // In all formats, the file is at least 24 bytes big, so we'll read that always
\par \cf2   \cf1 unsigned\cf2  \cf1 char\cf2  buf[24]; fread(buf,1,24,f);
\par 
\par   \cf0 // For JPEGs, we need to read the first 12 bytes of each chunk.
\par \cf2   \cf0 // We'll read those 12 bytes at buf+2...buf+14, i.e. overwriting the existing buf.
\par \cf2   \cf1 if\cf2  (buf[0]==0xFF && buf[1]==0xD8 && buf[2]==0xFF && buf[3]==0xE0 && buf[6]=='J' && buf[7]=='F' && buf[8]=='I' && buf[9]=='F')
\par   \{ \cf1 long\cf2  pos=2;
\par     \cf1 while\cf2  (buf[2]==0xFF)
\par     \{ \cf1 if\cf2  (buf[3]==0xC0 || buf[3]==0xC1 || buf[3]==0xC2 || buf[3]==0xC3 || buf[3]==0xC9 || buf[3]==0xCA || buf[3]==0xCB) \cf1 break\cf2 ;
\par       pos += 2+(buf[4]<<8)+buf[5];
\par       \cf1 if\cf2  (pos+12>len) \cf1 break\cf2 ;
\par       fseek(f,pos,SEEK_SET); fread(buf+2,1,12,f);
\par     \}
\par   \}
\par 
\par   fclose(f);
\par 
\par   \cf0 // JPEG: (first two bytes of buf are first two bytes of the jpeg file; rest of buf is the DCT frame
\par \cf2   \cf1 if\cf2  (buf[0]==0xFF && buf[1]==0xD8 && buf[2]==0xFF)
\par   \{ *y = (buf[7]<<8) + buf[8];
\par     *x = (buf[9]<<8) + buf[10];
\par 	  \cf1 if\cf2 (*y>4200) (*y)*=(4200*(*x)/(*y));
\par 	  
\par 
\par     \cf0 //cout << *x << endl;
\par \cf2     \cf1 return\cf2  \cf1 true\cf2 ;
\par   \}                                                                                                                    
\par   \cf0 // GIF: first three bytes say "GIF", next three give version number. Then dimensions                    
\par \cf2   \cf1 if\cf2  (buf[0]=='G' && buf[1]=='I' && buf[2]=='F')
\par   \{ *x = buf[6] + (buf[7]<<8);
\par     *y = buf[8] + (buf[9]<<8);
\par     \cf1 return\cf2  \cf1 true\cf2 ;
\par   \}
\par 
\par   \cf0 // PNG: the first frame is by definition an IHDR frame, which gives dimensions
\par \cf2   \cf1 if\cf2  ( buf[0]==0x89 && buf[1]=='P' && buf[2]=='N' && buf[3]=='G' && buf[4]==0x0D && buf[5]==0x0A && buf[6]==0x1A && buf[7]==0x0A
\par     && buf[12]=='I' && buf[13]=='H' && buf[14]=='D' && buf[15]=='R')
\par   \{ *x = (buf[16]<<24) + (buf[17]<<16) + (buf[18]<<8) + (buf[19]<<0);
\par     *y = (buf[20]<<24) + (buf[21]<<16) + (buf[22]<<8) + (buf[23]<<0);
\par     \cf1 return\cf2  \cf1 true\cf2 ;
\par   \}
\par 	\cf1 return\cf2  \cf1 false\cf2 ;
\par \}
\par 
\par \cf1 int\cf2  CXFullBlue(BYTE* blue, BYTE* green, BYTE* red)
\par \{	\cf0 // fancy stuff, not something serious
\par \cf2 	\cf1 if\cf2 (
\par 		((*red+32)<(*blue))&&
\par 		((*green+32)<(*blue))&&
\par 		((*blue)>16)&&
\par 		TRUE)
\par 	\{
\par 		*red = 0;
\par 		*green = 0;
\par 		*blue = 255;
\par 	\}
\par 	\cf1 return\cf2  0;
\par \}
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par \cf0 /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
\par /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
\par /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
\par /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////`
\par }